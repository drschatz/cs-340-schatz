{
  "title": "MP1",
  "subtitle": "Debugging",
  "author": "Wade Fagen-Ulmschneider",
  "body": {
    "raw": "\nThis is not a full MP.\nIt is **dramatically easier** than other MPs.\nDon't plan your time on other MPs based on this one.\n\nThe purposes of this MP is to have you see some of the functionality the VS Code debugger can do.\n\nIs it possible to create the required `gif.c` without doing these two things?\nYes.\nShould you do that?\nNo.\n\n# Fetch starter code\n\nWe have some initial code for your `mp1` for you to get started.\nDownload it from [`mp1.zip`](mp1.zip) and unzip it on your computer into the `cs340` directory you created during the environment setup.\n\n# Use Visual Studio Code\n\nVisual Studio Code (more often called VS Code) is an Integrated Development Environment (IDE) with many features shared with other IDEs.\nLearning to use it well will help you feel comfortable in other IDEs you may use in the future.\n\n## Projects\n\nIDEs have the notion of projects, which contain a set of files related to a single task or program.\nTypically, these reside in a folder and all of its subfolders.\nIn this class, each MP will be its own project, meaning you need to open VS Code in `mp1` or `mp2` or the like, not in some parent folder that contains them all.\n\nA folder that is set up to be a VS Code project will have inside of it a folder named `.vscode`.\nIn many systems files and folders with names that start with a `.` are hidden from view.\n\nTo open the `mp1` folder in VS Code, do one of the following:\n\n- From a terminal, `cd` into the `mp1` folder and run `code .`\n- Inside of VS Code, use File → Open Folder to open a new folder.\n\n## Integrated Terminal\n\nIDEs give access to the terminal, but often add configuration so that it's got everything needed to build the project ready to use.\nTo open VS Code's integrated terminal, use the keyboard shortcut Ctrl+~.\n\nUsing the integrated terminal, let's verify you are all set up for running C programs by doing the following:\n\n- On your terminal, run `make` to compile the provided code.\n- If you receive any errors, read the error messages. They will often be helpful to describe what's going wrong. If you're stuck here, reach out to get help!\n\n## Visual Debugger\n\nIDEs provide a user interface over the normal debugger tools for your language.\nIn VS Code, the debugger tool to use and how to attach it to the visual debugger is defined in `.vscode/launch.json`.\nDesigning these configuration files is not a goal of this course, so we provide them for each MP.\n\nOur `launch.json` files for `C` programs use `Makefile`s, one of the oldest and best-established command-line build management tools.\nYou can compile your code from the command line by typing `make` and run any tests we provided by typing `make test`.\nThe `launch.json` will do these two commands but attach a debugger to the running code, and may also have other commands for handling specific cases in some MPs.\n\nYou can run VS Code's debugger in two ways:\n\n- On the left side of Visual Studio Code, find the \"Run and Debug\" Interface\n- Once on the \"Run and Debug\" interface, find the green \"Debug\" arrow to start your program with a visual debugger\n\nDepending on the project, it may ask you to pick a launch configuration to run and may ask for per-run configuration.\n\nFor MP1, start by accepting the defaults when you run the debugger.\nAfter a moment the debugger will pause execution because of a segmentation fault.\n\n# Debug the Code\n\nTo help you learn how to use the debugger, we provide a version of `gif.c` that has multiple bugs inserted.\nEach bug is designed to help you see the value of a different aspect of the debugger.\n\nEach bug can be fixed by deleting a single line of code in `gif.c`. That's obviously not true of most real bugs: they tend to span many lines and even many files. Our goal in this MP is not to show you what real bugs look like, it's to show you what the debugger can do.\n\n## Segmentation fault\n\nA segmentation fault occurs when code tries to dereference a pointer to memory that is not in use.\nMemory references occur with the `*address`, `address->`, and `address[offset]` operators.\nDebuggers are very good at locating segmentation faults, but the bug that caused the fault is often in an earlier line that computed the address (or failed to do so).\n\nMP1 has several segmentation faults.\n\n## Call Stack Inspection\n\nWhen the debugger pauses, either on an error or because you added a breakpoint, the \"Run and Debug\" window shows a wealth of useful debugging information.\n\nOne panel is labeled \"Call Stack\". It will list the function calls that were called leading to where your program is currently paused. You can **click on them** to jump to their location in code.\n\nIn a call stack, the top is the most recent function called. The call stack is very useful for finding **infinite recursion** if you see the same function name again and again and again. You will want to reference the call stack for several bugs in `mp1`.\n\n## Pause-and-step\n\nIf there's an infinite loop, the program will appear to make no progress.\nIn that case, you can pause the debugger and step through the code to see what is happening.\n\nPressing the left-most \"Pause\" button will pause the execution of the program and provide you information about the current point of execution. When the program is paused:\n\n- You can **hover over variables** to see the values their hold\n- You can **view the call stack** and other debugging information\n- You can **use the control window** to step through your code line-by-line\n\n## Breakpoints\n\nWhen a program is doing the wrong thing, the most common approach to debug is to set a breakpoint.\nThis means picking a line of code and telling the debugger to pause when it reaches that line (before it runs it).\n\nTo set a breakpoint, **click on the space immediately to the left of the line number**. A bright red dot will appear to indicate that an active breakpoint is set.\n\nIn the example above, execution will pause after running Line 834 but before running Line 835. Since it's paused, you can inspect all of the variables at the exact moment before running Line 835. If you resume the program and the breakpoint is encountered again, it will pause again.\n\nIf you've done print-based debugging before, that's a sloppy way of trying to approximate a breakpoint + hovering over variables without using a debugger.\n\n## Watches and Beyond\n\nSometimes a variable changes many times, with the information you need to debug it appearing and then disappearing later.\nThere are multiple debugging tools for these situations, which can get quite involved.\n\nIn MP1 we have one bug that could benefit from these tools, though it could also be debugged with a breakpoint and stepping if you are patient.\nAfter you've fixed all the obvious bugs the code will run but it won't do very much.\n\nThere's still another bug: logic error in the resulting behavior, one of the hardest kinds of bugs to find because nothing crashes. To help you find it, **there's a secret message** explaining how to fix it inside the global `message` variable, but that message is only there part-way through a run of the program. Find the message and make the final fix to complete the MP.\n\n# Submission and Grading\n\nOnly edit `gif.c`, none of the other files we provide.\n`gif.c` is the only file you can upload so if you change anything else your code won't work the same for you as it does for us.\n\nWhen you think you are done, `make test` will run all our tests and report what grade we think you've earned.\n\nOnce you've passed all the tests, submit your code on the upload site.\n\nThe final line of output from `make test` will be `SCORE: 0 / 1` or `SCORE: 1 / 1`:\nthis tells you how much credit you'll get if you submit this code.\n\nYou may submit as often as you like, including replacing old submissions.\nThis is true of all MPs.\nOnly your last submission (prior to the end of the late submission window) will be included in your grade.\n",
    "html": "<p>This is not a full MP.\nIt is <strong>dramatically easier</strong> than other MPs.\nDon't plan your time on other MPs based on this one.</p>\n<p>The purposes of this MP is to have you see some of the functionality the VS Code debugger can do.</p>\n<p>Is it possible to create the required <code>gif.c</code> without doing these two things?\nYes.\nShould you do that?\nNo.</p>\n<h1>Fetch starter code</h1>\n<p>We have some initial code for your <code>mp1</code> for you to get started.\nDownload it from <a href=\"mp1.zip\"><code>mp1.zip</code></a> and unzip it on your computer into the <code>cs340</code> directory you created during the environment setup.</p>\n<h1>Use Visual Studio Code</h1>\n<p>Visual Studio Code (more often called VS Code) is an Integrated Development Environment (IDE) with many features shared with other IDEs.\nLearning to use it well will help you feel comfortable in other IDEs you may use in the future.</p>\n<h2>Projects</h2>\n<p>IDEs have the notion of projects, which contain a set of files related to a single task or program.\nTypically, these reside in a folder and all of its subfolders.\nIn this class, each MP will be its own project, meaning you need to open VS Code in <code>mp1</code> or <code>mp2</code> or the like, not in some parent folder that contains them all.</p>\n<p>A folder that is set up to be a VS Code project will have inside of it a folder named <code>.vscode</code>.\nIn many systems files and folders with names that start with a <code>.</code> are hidden from view.</p>\n<p>To open the <code>mp1</code> folder in VS Code, do one of the following:</p>\n<ul>\n<li>From a terminal, <code>cd</code> into the <code>mp1</code> folder and run <code>code .</code></li>\n<li>Inside of VS Code, use File → Open Folder to open a new folder.</li>\n</ul>\n<h2>Integrated Terminal</h2>\n<p>IDEs give access to the terminal, but often add configuration so that it's got everything needed to build the project ready to use.\nTo open VS Code's integrated terminal, use the keyboard shortcut Ctrl+~.</p>\n<p>Using the integrated terminal, let's verify you are all set up for running C programs by doing the following:</p>\n<ul>\n<li>On your terminal, run <code>make</code> to compile the provided code.</li>\n<li>If you receive any errors, read the error messages. They will often be helpful to describe what's going wrong. If you're stuck here, reach out to get help!</li>\n</ul>\n<h2>Visual Debugger</h2>\n<p>IDEs provide a user interface over the normal debugger tools for your language.\nIn VS Code, the debugger tool to use and how to attach it to the visual debugger is defined in <code>.vscode/launch.json</code>.\nDesigning these configuration files is not a goal of this course, so we provide them for each MP.</p>\n<p>Our <code>launch.json</code> files for <code>C</code> programs use <code>Makefile</code>s, one of the oldest and best-established command-line build management tools.\nYou can compile your code from the command line by typing <code>make</code> and run any tests we provided by typing <code>make test</code>.\nThe <code>launch.json</code> will do these two commands but attach a debugger to the running code, and may also have other commands for handling specific cases in some MPs.</p>\n<p>You can run VS Code's debugger in two ways:</p>\n<ul>\n<li>On the left side of Visual Studio Code, find the \"Run and Debug\" Interface</li>\n<li>Once on the \"Run and Debug\" interface, find the green \"Debug\" arrow to start your program with a visual debugger</li>\n</ul>\n<p>Depending on the project, it may ask you to pick a launch configuration to run and may ask for per-run configuration.</p>\n<p>For MP1, start by accepting the defaults when you run the debugger.\nAfter a moment the debugger will pause execution because of a segmentation fault.</p>\n<h1>Debug the Code</h1>\n<p>To help you learn how to use the debugger, we provide a version of <code>gif.c</code> that has multiple bugs inserted.\nEach bug is designed to help you see the value of a different aspect of the debugger.</p>\n<p>Each bug can be fixed by deleting a single line of code in <code>gif.c</code>. That's obviously not true of most real bugs: they tend to span many lines and even many files. Our goal in this MP is not to show you what real bugs look like, it's to show you what the debugger can do.</p>\n<h2>Segmentation fault</h2>\n<p>A segmentation fault occurs when code tries to dereference a pointer to memory that is not in use.\nMemory references occur with the <code>*address</code>, <code>address-></code>, and <code>address[offset]</code> operators.\nDebuggers are very good at locating segmentation faults, but the bug that caused the fault is often in an earlier line that computed the address (or failed to do so).</p>\n<p>MP1 has several segmentation faults.</p>\n<h2>Call Stack Inspection</h2>\n<p>When the debugger pauses, either on an error or because you added a breakpoint, the \"Run and Debug\" window shows a wealth of useful debugging information.</p>\n<p>One panel is labeled \"Call Stack\". It will list the function calls that were called leading to where your program is currently paused. You can <strong>click on them</strong> to jump to their location in code.</p>\n<p>In a call stack, the top is the most recent function called. The call stack is very useful for finding <strong>infinite recursion</strong> if you see the same function name again and again and again. You will want to reference the call stack for several bugs in <code>mp1</code>.</p>\n<h2>Pause-and-step</h2>\n<p>If there's an infinite loop, the program will appear to make no progress.\nIn that case, you can pause the debugger and step through the code to see what is happening.</p>\n<p>Pressing the left-most \"Pause\" button will pause the execution of the program and provide you information about the current point of execution. When the program is paused:</p>\n<ul>\n<li>You can <strong>hover over variables</strong> to see the values their hold</li>\n<li>You can <strong>view the call stack</strong> and other debugging information</li>\n<li>You can <strong>use the control window</strong> to step through your code line-by-line</li>\n</ul>\n<h2>Breakpoints</h2>\n<p>When a program is doing the wrong thing, the most common approach to debug is to set a breakpoint.\nThis means picking a line of code and telling the debugger to pause when it reaches that line (before it runs it).</p>\n<p>To set a breakpoint, <strong>click on the space immediately to the left of the line number</strong>. A bright red dot will appear to indicate that an active breakpoint is set.</p>\n<p>In the example above, execution will pause after running Line 834 but before running Line 835. Since it's paused, you can inspect all of the variables at the exact moment before running Line 835. If you resume the program and the breakpoint is encountered again, it will pause again.</p>\n<p>If you've done print-based debugging before, that's a sloppy way of trying to approximate a breakpoint + hovering over variables without using a debugger.</p>\n<h2>Watches and Beyond</h2>\n<p>Sometimes a variable changes many times, with the information you need to debug it appearing and then disappearing later.\nThere are multiple debugging tools for these situations, which can get quite involved.</p>\n<p>In MP1 we have one bug that could benefit from these tools, though it could also be debugged with a breakpoint and stepping if you are patient.\nAfter you've fixed all the obvious bugs the code will run but it won't do very much.</p>\n<p>There's still another bug: logic error in the resulting behavior, one of the hardest kinds of bugs to find because nothing crashes. To help you find it, <strong>there's a secret message</strong> explaining how to fix it inside the global <code>message</code> variable, but that message is only there part-way through a run of the program. Find the message and make the final fix to complete the MP.</p>\n<h1>Submission and Grading</h1>\n<p>Only edit <code>gif.c</code>, none of the other files we provide.\n<code>gif.c</code> is the only file you can upload so if you change anything else your code won't work the same for you as it does for us.</p>\n<p>When you think you are done, <code>make test</code> will run all our tests and report what grade we think you've earned.</p>\n<p>Once you've passed all the tests, submit your code on the upload site.</p>\n<p>The final line of output from <code>make test</code> will be <code>SCORE: 0 / 1</code> or <code>SCORE: 1 / 1</code>:\nthis tells you how much credit you'll get if you submit this code.</p>\n<p>You may submit as often as you like, including replacing old submissions.\nThis is true of all MPs.\nOnly your last submission (prior to the end of the late submission window) will be included in your grade.</p>"
  },
  "_id": "mps/mp1.md",
  "_raw": {
    "sourceFilePath": "mps/mp1.md",
    "sourceFileName": "mp1.md",
    "sourceFileDir": "mps",
    "contentType": "markdown",
    "flattenedPath": "mps/mp1"
  },
  "type": "MP",
  "url": "/mps/mp1",
  "slug": "mp1",
  "number": 1
}