[
  {
    "title": "MP0",
    "subtitle": "IDE and Debugger",
    "author": "Wade Fagen-Ulmschneider",
    "body": {
      "raw": "\nThis is not a full MP; it is primarily testing your setup and ensuring you are ready for subsequent MPs.\nIt is **dramatically easier** than other MPs.\nDon't plan your time on other MPs based on this one.\n\nThe purposes of this MP are:\n\n1. Ensure you are set up to do other C-language MPs in this course.\n2. Have you see some of the tools the VS Code debugger can do.\n\nIs it possible to create the required `gif.c` without doing these two things? Yes. Should you do that? No.\n\n# Set up your environment\n\nFollow the directions on the MP environment setup page. We'll only use the local toolchain in this MP.\n\n# Fetch starter code\n\nWe have some initial code for your `mp0` for you to get started. Download it from `mp0.zip` and unzip it on your computer into the `cs340` directory you created during the environment setup.\n\n# Use Visual Studio Code\n\nVisual Studio Code (more often called VS Code) is an Integrated Development Environment (IDE) with many features shared with other IDEs. Learning to use it well will help you feel comfortable in other IDEs you may use in the future.\n\n## Projects\n\nIDEs have the notion of projects, which contain a set of files related to a single task or program. Typically, these reside in a folder and all of its subfolders. In this class, each MP will be its own project, meaning you need to open VS Code in `mp0` or `mp1` or the like, not in some parent folder that contains them all.\n\nA folder that is set up to be a VS Code project will have inside of it a folder named `.vscode`. In many systems files and folders with names that start with a `.` are hidden from view.\n\nTo open the `mp0` folder in VS Code, do one of the following:\n\n- From a terminal, `cd` into the `mp0` folder and run `code .`\n- Inside of VS Code, use File → Open Folder to open a new folder.\n\n## Integrated Terminal\n\nIDEs give access to the terminal, but often add configuration so that it's got everything needed to build the project ready to use. To open VS Code's integrated terminal, use the keyboard shortcut Ctrl+~.\n\nUsing the integrated terminal, let's verify you are all set up for running C programs by doing the following:\n\n- On your terminal, run `make` to compile the provided code.\n- If you receive any errors, read the error messages. They will often be helpful to describe what's going wrong. If you're stuck here, reach out to get help!\n\n## Visual Debugger\n\nIDEs provide a user interface over the normal debugger tools for your language. In VS Code, the debugger tool to use and how to attach it to the visual debugger is defined in `.vscode/launch.json`. Designing these configuration files is not a goal of this course, so we provide them for each MP.\n\nOur `launch.json` files for `C` programs use `Makefile`s, one of the oldest and best-established command-line build management tools. You can compile your code from the command line by typing `make` and run any tests we provided by typing `make test`. The `launch.json` will do these two commands but attach a debugger to the running code, and may also have other commands for handling specific cases in some MPs.\n\nYou can run VS Code's debugger in two ways:\n\n- On the left side of Visual Studio Code, find the \"Run and Debug\" Interface\n- Once on the \"Run and Debug\" interface, find the green \"Debug\" arrow to start your program with a visual debugger\n\nDepending on the project, it may ask you to pick a launch configuration to run and may ask for per-run configuration.\n\nFor MP0, start by accepting the defaults when you run the debugger. After a moment the debugger will pause execution because of a segmentation fault.\n\n# Debug the Code\n\nTo help you learn how to use the debugger, we provide a version of `gif.c` that has multiple bugs inserted. Each bug is designed to help you see the value of a different aspect of the debugger.\n\nEach bug can be fixed by editing a single line of code in `gif.c`: all but one by commenting out a line and the last by making one change to a line. That's obviously not true of most real bugs: they tend to span many lines and even many files. Our goal in this MP is not to show you what real bugs look like, it's to show you what the debugger can do.\n\n## Segmentation fault\n\nA segmentation fault occurs when code tries to dereference a pointer to memory that is not in use. Memory references occur with the `*address`, `address->`, and `address[offset]` operators. Debuggers are very good at locating segmentation faults, but the bug that caused the fault is often in an earlier line that computed the address (or failed to do so).\n\nMP0 has several segmentation faults.\n\n## Stack Smashing\n\nStack smashing occurs when code tries to change memory that belongs to a different function's activation record.\n\nRecall that each function is given a region of memory on the call stack, called an activation record, in which to store its arguments and local variables. The function that called the current function's activation record is right after the current activation record in memory. In between these two the compiler inserts special guards to make sure memory accesses don't cross the boundary: if they do, that's stack smashing.\n\nStack smashing is one of several bugs that will have information printed to the terminal, not just alerted in the debugger.\n\nMP0 has only one stack smashing error.\n\n## Call Stack Inspection\n\nWhen the debugger pauses, either on an error or because you added a breakpoint, the \"Run and Debug\" window shows a wealth of useful debugging information.\n\nOne panel is labeled \"Call Stack\". It will list the function calls that were called leading to where your program is currently paused. You can click on them to jump to their location in code.\n\nIn a call stack, the top is the most recent function called. The call stack is very useful for finding infinite recursion if you see the same function name again and again and again. You will want to reference the call stack for several bugs in `mp0`.\n\n## Pause-and-step\n\nIf there's an infinite loop, the program will appear to make no progress. In that case, you can pause the debugger and step through the code to see what is happening.\n\nPressing the left-most \"Pause\" button will pause the execution of the program and provide you information about the current point of execution. When the program is paused:\n\n- You can hover over variables to see the values their hold\n- You can view the call stack and other debugging information\n- You can use the control window to step through your code line-by-line\n\n## Breakpoints\n\nWhen a program is doing the wrong thing, the most common approach to debug is to set a breakpoint. This means picking a line of code and telling the debugger to pause when it reaches that line (before it runs it).\n\nTo set a breakpoint, click on the space immediately to the left of the line number. A bright red dot will appear to indicate that an active breakpoint is set.\n\nIn the example above, execution will pause after running Line 834 but before running Line 835. Since it's paused, you can inspect all of the variables at the exact moment before running Line 835. If you resume the program and the breakpoint is encountered again, it will pause again.\n\nIf you've done print-based debugging before, that's a sloppy way of trying to approximate a breakpoint + hovering over variables without using a debugger.\n\n## Watches and Beyond\n\nSometimes a variable changes many times, with the information you need to debug it appearing and then disappearing later. There are multiple debugging tools for these situations, which can get quite involved; two of the simpler such tools are watches and conditional breakpoints.\n\nIn MP0 we have one bug that could benefit from these tools, though it could also be debugged with a breakpoint and stepping if you are patient. After you've fixed all the obvious bugs the code will run but it won't do very much.\n\nThere's still another bug: logic error in the resulting behavior, one of the hardest kinds of bugs to find because nothing crashes. To help you find it, there's a secret message explaining how to fix it inside the global `message` variable, but that message is only there part-way through a run of the program. Find the message and make the final fix to complete the MP.\n\n# Submission and Grading\n\nOnly edit `gif.c`, none of the other files we provide. `gif.c` is the only file you can upload so if you change anything else your code won't work the same for you as it does for us.\n\nWhen you think you are done, `make test` will run all our tests and report what grade we think you've earned.\n\nOnce you've passed all the tests, submit your code on the upload site.\n\nThis MP has very low weight, all-or-nothing grading, and accepts late submissions at no grade penalty.\n\nThe final line of output from `make test` will be `SCORE: 0 / 1` or `SCORE: 1 / 1`: this tells you how much credit you'll get if you submit this code.\n\nYou may submit as often as you like, including replacing old submissions. This is true of all MPs. Only your last submission (prior to the end of the late submission window) will be included in your grade.\n",
      "html": "<p>This is not a full MP; it is primarily testing your setup and ensuring you are ready for subsequent MPs.\nIt is <strong>dramatically easier</strong> than other MPs.\nDon't plan your time on other MPs based on this one.</p>\n<p>The purposes of this MP are:</p>\n<ol>\n<li>Ensure you are set up to do other C-language MPs in this course.</li>\n<li>Have you see some of the tools the VS Code debugger can do.</li>\n</ol>\n<p>Is it possible to create the required <code>gif.c</code> without doing these two things? Yes. Should you do that? No.</p>\n<h1>Set up your environment</h1>\n<p>Follow the directions on the MP environment setup page. We'll only use the local toolchain in this MP.</p>\n<h1>Fetch starter code</h1>\n<p>We have some initial code for your <code>mp0</code> for you to get started. Download it from <code>mp0.zip</code> and unzip it on your computer into the <code>cs340</code> directory you created during the environment setup.</p>\n<h1>Use Visual Studio Code</h1>\n<p>Visual Studio Code (more often called VS Code) is an Integrated Development Environment (IDE) with many features shared with other IDEs. Learning to use it well will help you feel comfortable in other IDEs you may use in the future.</p>\n<h2>Projects</h2>\n<p>IDEs have the notion of projects, which contain a set of files related to a single task or program. Typically, these reside in a folder and all of its subfolders. In this class, each MP will be its own project, meaning you need to open VS Code in <code>mp0</code> or <code>mp1</code> or the like, not in some parent folder that contains them all.</p>\n<p>A folder that is set up to be a VS Code project will have inside of it a folder named <code>.vscode</code>. In many systems files and folders with names that start with a <code>.</code> are hidden from view.</p>\n<p>To open the <code>mp0</code> folder in VS Code, do one of the following:</p>\n<ul>\n<li>From a terminal, <code>cd</code> into the <code>mp0</code> folder and run <code>code .</code></li>\n<li>Inside of VS Code, use File → Open Folder to open a new folder.</li>\n</ul>\n<h2>Integrated Terminal</h2>\n<p>IDEs give access to the terminal, but often add configuration so that it's got everything needed to build the project ready to use. To open VS Code's integrated terminal, use the keyboard shortcut Ctrl+~.</p>\n<p>Using the integrated terminal, let's verify you are all set up for running C programs by doing the following:</p>\n<ul>\n<li>On your terminal, run <code>make</code> to compile the provided code.</li>\n<li>If you receive any errors, read the error messages. They will often be helpful to describe what's going wrong. If you're stuck here, reach out to get help!</li>\n</ul>\n<h2>Visual Debugger</h2>\n<p>IDEs provide a user interface over the normal debugger tools for your language. In VS Code, the debugger tool to use and how to attach it to the visual debugger is defined in <code>.vscode/launch.json</code>. Designing these configuration files is not a goal of this course, so we provide them for each MP.</p>\n<p>Our <code>launch.json</code> files for <code>C</code> programs use <code>Makefile</code>s, one of the oldest and best-established command-line build management tools. You can compile your code from the command line by typing <code>make</code> and run any tests we provided by typing <code>make test</code>. The <code>launch.json</code> will do these two commands but attach a debugger to the running code, and may also have other commands for handling specific cases in some MPs.</p>\n<p>You can run VS Code's debugger in two ways:</p>\n<ul>\n<li>On the left side of Visual Studio Code, find the \"Run and Debug\" Interface</li>\n<li>Once on the \"Run and Debug\" interface, find the green \"Debug\" arrow to start your program with a visual debugger</li>\n</ul>\n<p>Depending on the project, it may ask you to pick a launch configuration to run and may ask for per-run configuration.</p>\n<p>For MP0, start by accepting the defaults when you run the debugger. After a moment the debugger will pause execution because of a segmentation fault.</p>\n<h1>Debug the Code</h1>\n<p>To help you learn how to use the debugger, we provide a version of <code>gif.c</code> that has multiple bugs inserted. Each bug is designed to help you see the value of a different aspect of the debugger.</p>\n<p>Each bug can be fixed by editing a single line of code in <code>gif.c</code>: all but one by commenting out a line and the last by making one change to a line. That's obviously not true of most real bugs: they tend to span many lines and even many files. Our goal in this MP is not to show you what real bugs look like, it's to show you what the debugger can do.</p>\n<h2>Segmentation fault</h2>\n<p>A segmentation fault occurs when code tries to dereference a pointer to memory that is not in use. Memory references occur with the <code>*address</code>, <code>address-></code>, and <code>address[offset]</code> operators. Debuggers are very good at locating segmentation faults, but the bug that caused the fault is often in an earlier line that computed the address (or failed to do so).</p>\n<p>MP0 has several segmentation faults.</p>\n<h2>Stack Smashing</h2>\n<p>Stack smashing occurs when code tries to change memory that belongs to a different function's activation record.</p>\n<p>Recall that each function is given a region of memory on the call stack, called an activation record, in which to store its arguments and local variables. The function that called the current function's activation record is right after the current activation record in memory. In between these two the compiler inserts special guards to make sure memory accesses don't cross the boundary: if they do, that's stack smashing.</p>\n<p>Stack smashing is one of several bugs that will have information printed to the terminal, not just alerted in the debugger.</p>\n<p>MP0 has only one stack smashing error.</p>\n<h2>Call Stack Inspection</h2>\n<p>When the debugger pauses, either on an error or because you added a breakpoint, the \"Run and Debug\" window shows a wealth of useful debugging information.</p>\n<p>One panel is labeled \"Call Stack\". It will list the function calls that were called leading to where your program is currently paused. You can click on them to jump to their location in code.</p>\n<p>In a call stack, the top is the most recent function called. The call stack is very useful for finding infinite recursion if you see the same function name again and again and again. You will want to reference the call stack for several bugs in <code>mp0</code>.</p>\n<h2>Pause-and-step</h2>\n<p>If there's an infinite loop, the program will appear to make no progress. In that case, you can pause the debugger and step through the code to see what is happening.</p>\n<p>Pressing the left-most \"Pause\" button will pause the execution of the program and provide you information about the current point of execution. When the program is paused:</p>\n<ul>\n<li>You can hover over variables to see the values their hold</li>\n<li>You can view the call stack and other debugging information</li>\n<li>You can use the control window to step through your code line-by-line</li>\n</ul>\n<h2>Breakpoints</h2>\n<p>When a program is doing the wrong thing, the most common approach to debug is to set a breakpoint. This means picking a line of code and telling the debugger to pause when it reaches that line (before it runs it).</p>\n<p>To set a breakpoint, click on the space immediately to the left of the line number. A bright red dot will appear to indicate that an active breakpoint is set.</p>\n<p>In the example above, execution will pause after running Line 834 but before running Line 835. Since it's paused, you can inspect all of the variables at the exact moment before running Line 835. If you resume the program and the breakpoint is encountered again, it will pause again.</p>\n<p>If you've done print-based debugging before, that's a sloppy way of trying to approximate a breakpoint + hovering over variables without using a debugger.</p>\n<h2>Watches and Beyond</h2>\n<p>Sometimes a variable changes many times, with the information you need to debug it appearing and then disappearing later. There are multiple debugging tools for these situations, which can get quite involved; two of the simpler such tools are watches and conditional breakpoints.</p>\n<p>In MP0 we have one bug that could benefit from these tools, though it could also be debugged with a breakpoint and stepping if you are patient. After you've fixed all the obvious bugs the code will run but it won't do very much.</p>\n<p>There's still another bug: logic error in the resulting behavior, one of the hardest kinds of bugs to find because nothing crashes. To help you find it, there's a secret message explaining how to fix it inside the global <code>message</code> variable, but that message is only there part-way through a run of the program. Find the message and make the final fix to complete the MP.</p>\n<h1>Submission and Grading</h1>\n<p>Only edit <code>gif.c</code>, none of the other files we provide. <code>gif.c</code> is the only file you can upload so if you change anything else your code won't work the same for you as it does for us.</p>\n<p>When you think you are done, <code>make test</code> will run all our tests and report what grade we think you've earned.</p>\n<p>Once you've passed all the tests, submit your code on the upload site.</p>\n<p>This MP has very low weight, all-or-nothing grading, and accepts late submissions at no grade penalty.</p>\n<p>The final line of output from <code>make test</code> will be <code>SCORE: 0 / 1</code> or <code>SCORE: 1 / 1</code>: this tells you how much credit you'll get if you submit this code.</p>\n<p>You may submit as often as you like, including replacing old submissions. This is true of all MPs. Only your last submission (prior to the end of the late submission window) will be included in your grade.</p>"
    },
    "_id": "mps/mp0.md",
    "_raw": {
      "sourceFilePath": "mps/mp0.md",
      "sourceFileName": "mp0.md",
      "sourceFileDir": "mps",
      "contentType": "markdown",
      "flattenedPath": "mps/mp0"
    },
    "type": "MP",
    "url": "/mps/mp0",
    "slug": "mp0",
    "number": 0
  },
  {
    "title": "MP1",
    "subtitle": "Debugging",
    "author": "Wade Fagen-Ulmschneider",
    "body": {
      "raw": "\nThis is not a full MP.\nIt is **dramatically easier** than other MPs.\nDon't plan your time on other MPs based on this one.\n\nThe purposes of this MP is to have you see some of the functionality the VS Code debugger can do.\n\nIs it possible to create the required `gif.c` without doing these two things?\nYes.\nShould you do that?\nNo.\n\n# Fetch starter code\n\nWe have some initial code for your `mp1` for you to get started.\nDownload it from [`mp1.zip`](mp1.zip) and unzip it on your computer into the `cs340` directory you created during the environment setup.\n\n# Use Visual Studio Code\n\nVisual Studio Code (more often called VS Code) is an Integrated Development Environment (IDE) with many features shared with other IDEs.\nLearning to use it well will help you feel comfortable in other IDEs you may use in the future.\n\n## Projects\n\nIDEs have the notion of projects, which contain a set of files related to a single task or program.\nTypically, these reside in a folder and all of its subfolders.\nIn this class, each MP will be its own project, meaning you need to open VS Code in `mp1` or `mp2` or the like, not in some parent folder that contains them all.\n\nA folder that is set up to be a VS Code project will have inside of it a folder named `.vscode`.\nIn many systems files and folders with names that start with a `.` are hidden from view.\n\nTo open the `mp1` folder in VS Code, do one of the following:\n\n- From a terminal, `cd` into the `mp1` folder and run `code .`\n- Inside of VS Code, use File → Open Folder to open a new folder.\n\n## Integrated Terminal\n\nIDEs give access to the terminal, but often add configuration so that it's got everything needed to build the project ready to use.\nTo open VS Code's integrated terminal, use the keyboard shortcut Ctrl+~.\n\nUsing the integrated terminal, let's verify you are all set up for running C programs by doing the following:\n\n- On your terminal, run `make` to compile the provided code.\n- If you receive any errors, read the error messages. They will often be helpful to describe what's going wrong. If you're stuck here, reach out to get help!\n\n## Visual Debugger\n\nIDEs provide a user interface over the normal debugger tools for your language.\nIn VS Code, the debugger tool to use and how to attach it to the visual debugger is defined in `.vscode/launch.json`.\nDesigning these configuration files is not a goal of this course, so we provide them for each MP.\n\nOur `launch.json` files for `C` programs use `Makefile`s, one of the oldest and best-established command-line build management tools.\nYou can compile your code from the command line by typing `make` and run any tests we provided by typing `make test`.\nThe `launch.json` will do these two commands but attach a debugger to the running code, and may also have other commands for handling specific cases in some MPs.\n\nYou can run VS Code's debugger in two ways:\n\n- On the left side of Visual Studio Code, find the \"Run and Debug\" Interface\n- Once on the \"Run and Debug\" interface, find the green \"Debug\" arrow to start your program with a visual debugger\n\nDepending on the project, it may ask you to pick a launch configuration to run and may ask for per-run configuration.\n\nFor MP1, start by accepting the defaults when you run the debugger.\nAfter a moment the debugger will pause execution because of a segmentation fault.\n\n# Debug the Code\n\nTo help you learn how to use the debugger, we provide a version of `gif.c` that has multiple bugs inserted.\nEach bug is designed to help you see the value of a different aspect of the debugger.\n\nEach bug can be fixed by deleting a single line of code in `gif.c`. That's obviously not true of most real bugs: they tend to span many lines and even many files. Our goal in this MP is not to show you what real bugs look like, it's to show you what the debugger can do.\n\n## Segmentation fault\n\nA segmentation fault occurs when code tries to dereference a pointer to memory that is not in use.\nMemory references occur with the `*address`, `address->`, and `address[offset]` operators.\nDebuggers are very good at locating segmentation faults, but the bug that caused the fault is often in an earlier line that computed the address (or failed to do so).\n\nMP1 has several segmentation faults.\n\n## Call Stack Inspection\n\nWhen the debugger pauses, either on an error or because you added a breakpoint, the \"Run and Debug\" window shows a wealth of useful debugging information.\n\nOne panel is labeled \"Call Stack\". It will list the function calls that were called leading to where your program is currently paused. You can **click on them** to jump to their location in code.\n\nIn a call stack, the top is the most recent function called. The call stack is very useful for finding **infinite recursion** if you see the same function name again and again and again. You will want to reference the call stack for several bugs in `mp1`.\n\n## Pause-and-step\n\nIf there's an infinite loop, the program will appear to make no progress.\nIn that case, you can pause the debugger and step through the code to see what is happening.\n\nPressing the left-most \"Pause\" button will pause the execution of the program and provide you information about the current point of execution. When the program is paused:\n\n- You can **hover over variables** to see the values their hold\n- You can **view the call stack** and other debugging information\n- You can **use the control window** to step through your code line-by-line\n\n## Breakpoints\n\nWhen a program is doing the wrong thing, the most common approach to debug is to set a breakpoint.\nThis means picking a line of code and telling the debugger to pause when it reaches that line (before it runs it).\n\nTo set a breakpoint, **click on the space immediately to the left of the line number**. A bright red dot will appear to indicate that an active breakpoint is set.\n\nIn the example above, execution will pause after running Line 834 but before running Line 835. Since it's paused, you can inspect all of the variables at the exact moment before running Line 835. If you resume the program and the breakpoint is encountered again, it will pause again.\n\nIf you've done print-based debugging before, that's a sloppy way of trying to approximate a breakpoint + hovering over variables without using a debugger.\n\n## Watches and Beyond\n\nSometimes a variable changes many times, with the information you need to debug it appearing and then disappearing later.\nThere are multiple debugging tools for these situations, which can get quite involved.\n\nIn MP1 we have one bug that could benefit from these tools, though it could also be debugged with a breakpoint and stepping if you are patient.\nAfter you've fixed all the obvious bugs the code will run but it won't do very much.\n\nThere's still another bug: logic error in the resulting behavior, one of the hardest kinds of bugs to find because nothing crashes. To help you find it, **there's a secret message** explaining how to fix it inside the global `message` variable, but that message is only there part-way through a run of the program. Find the message and make the final fix to complete the MP.\n\n# Submission and Grading\n\nOnly edit `gif.c`, none of the other files we provide.\n`gif.c` is the only file you can upload so if you change anything else your code won't work the same for you as it does for us.\n\nWhen you think you are done, `make test` will run all our tests and report what grade we think you've earned.\n\nOnce you've passed all the tests, submit your code on the upload site.\n\nThe final line of output from `make test` will be `SCORE: 0 / 1` or `SCORE: 1 / 1`:\nthis tells you how much credit you'll get if you submit this code.\n\nYou may submit as often as you like, including replacing old submissions.\nThis is true of all MPs.\nOnly your last submission (prior to the end of the late submission window) will be included in your grade.\n",
      "html": "<p>This is not a full MP.\nIt is <strong>dramatically easier</strong> than other MPs.\nDon't plan your time on other MPs based on this one.</p>\n<p>The purposes of this MP is to have you see some of the functionality the VS Code debugger can do.</p>\n<p>Is it possible to create the required <code>gif.c</code> without doing these two things?\nYes.\nShould you do that?\nNo.</p>\n<h1>Fetch starter code</h1>\n<p>We have some initial code for your <code>mp1</code> for you to get started.\nDownload it from <a href=\"mp1.zip\"><code>mp1.zip</code></a> and unzip it on your computer into the <code>cs340</code> directory you created during the environment setup.</p>\n<h1>Use Visual Studio Code</h1>\n<p>Visual Studio Code (more often called VS Code) is an Integrated Development Environment (IDE) with many features shared with other IDEs.\nLearning to use it well will help you feel comfortable in other IDEs you may use in the future.</p>\n<h2>Projects</h2>\n<p>IDEs have the notion of projects, which contain a set of files related to a single task or program.\nTypically, these reside in a folder and all of its subfolders.\nIn this class, each MP will be its own project, meaning you need to open VS Code in <code>mp1</code> or <code>mp2</code> or the like, not in some parent folder that contains them all.</p>\n<p>A folder that is set up to be a VS Code project will have inside of it a folder named <code>.vscode</code>.\nIn many systems files and folders with names that start with a <code>.</code> are hidden from view.</p>\n<p>To open the <code>mp1</code> folder in VS Code, do one of the following:</p>\n<ul>\n<li>From a terminal, <code>cd</code> into the <code>mp1</code> folder and run <code>code .</code></li>\n<li>Inside of VS Code, use File → Open Folder to open a new folder.</li>\n</ul>\n<h2>Integrated Terminal</h2>\n<p>IDEs give access to the terminal, but often add configuration so that it's got everything needed to build the project ready to use.\nTo open VS Code's integrated terminal, use the keyboard shortcut Ctrl+~.</p>\n<p>Using the integrated terminal, let's verify you are all set up for running C programs by doing the following:</p>\n<ul>\n<li>On your terminal, run <code>make</code> to compile the provided code.</li>\n<li>If you receive any errors, read the error messages. They will often be helpful to describe what's going wrong. If you're stuck here, reach out to get help!</li>\n</ul>\n<h2>Visual Debugger</h2>\n<p>IDEs provide a user interface over the normal debugger tools for your language.\nIn VS Code, the debugger tool to use and how to attach it to the visual debugger is defined in <code>.vscode/launch.json</code>.\nDesigning these configuration files is not a goal of this course, so we provide them for each MP.</p>\n<p>Our <code>launch.json</code> files for <code>C</code> programs use <code>Makefile</code>s, one of the oldest and best-established command-line build management tools.\nYou can compile your code from the command line by typing <code>make</code> and run any tests we provided by typing <code>make test</code>.\nThe <code>launch.json</code> will do these two commands but attach a debugger to the running code, and may also have other commands for handling specific cases in some MPs.</p>\n<p>You can run VS Code's debugger in two ways:</p>\n<ul>\n<li>On the left side of Visual Studio Code, find the \"Run and Debug\" Interface</li>\n<li>Once on the \"Run and Debug\" interface, find the green \"Debug\" arrow to start your program with a visual debugger</li>\n</ul>\n<p>Depending on the project, it may ask you to pick a launch configuration to run and may ask for per-run configuration.</p>\n<p>For MP1, start by accepting the defaults when you run the debugger.\nAfter a moment the debugger will pause execution because of a segmentation fault.</p>\n<h1>Debug the Code</h1>\n<p>To help you learn how to use the debugger, we provide a version of <code>gif.c</code> that has multiple bugs inserted.\nEach bug is designed to help you see the value of a different aspect of the debugger.</p>\n<p>Each bug can be fixed by deleting a single line of code in <code>gif.c</code>. That's obviously not true of most real bugs: they tend to span many lines and even many files. Our goal in this MP is not to show you what real bugs look like, it's to show you what the debugger can do.</p>\n<h2>Segmentation fault</h2>\n<p>A segmentation fault occurs when code tries to dereference a pointer to memory that is not in use.\nMemory references occur with the <code>*address</code>, <code>address-></code>, and <code>address[offset]</code> operators.\nDebuggers are very good at locating segmentation faults, but the bug that caused the fault is often in an earlier line that computed the address (or failed to do so).</p>\n<p>MP1 has several segmentation faults.</p>\n<h2>Call Stack Inspection</h2>\n<p>When the debugger pauses, either on an error or because you added a breakpoint, the \"Run and Debug\" window shows a wealth of useful debugging information.</p>\n<p>One panel is labeled \"Call Stack\". It will list the function calls that were called leading to where your program is currently paused. You can <strong>click on them</strong> to jump to their location in code.</p>\n<p>In a call stack, the top is the most recent function called. The call stack is very useful for finding <strong>infinite recursion</strong> if you see the same function name again and again and again. You will want to reference the call stack for several bugs in <code>mp1</code>.</p>\n<h2>Pause-and-step</h2>\n<p>If there's an infinite loop, the program will appear to make no progress.\nIn that case, you can pause the debugger and step through the code to see what is happening.</p>\n<p>Pressing the left-most \"Pause\" button will pause the execution of the program and provide you information about the current point of execution. When the program is paused:</p>\n<ul>\n<li>You can <strong>hover over variables</strong> to see the values their hold</li>\n<li>You can <strong>view the call stack</strong> and other debugging information</li>\n<li>You can <strong>use the control window</strong> to step through your code line-by-line</li>\n</ul>\n<h2>Breakpoints</h2>\n<p>When a program is doing the wrong thing, the most common approach to debug is to set a breakpoint.\nThis means picking a line of code and telling the debugger to pause when it reaches that line (before it runs it).</p>\n<p>To set a breakpoint, <strong>click on the space immediately to the left of the line number</strong>. A bright red dot will appear to indicate that an active breakpoint is set.</p>\n<p>In the example above, execution will pause after running Line 834 but before running Line 835. Since it's paused, you can inspect all of the variables at the exact moment before running Line 835. If you resume the program and the breakpoint is encountered again, it will pause again.</p>\n<p>If you've done print-based debugging before, that's a sloppy way of trying to approximate a breakpoint + hovering over variables without using a debugger.</p>\n<h2>Watches and Beyond</h2>\n<p>Sometimes a variable changes many times, with the information you need to debug it appearing and then disappearing later.\nThere are multiple debugging tools for these situations, which can get quite involved.</p>\n<p>In MP1 we have one bug that could benefit from these tools, though it could also be debugged with a breakpoint and stepping if you are patient.\nAfter you've fixed all the obvious bugs the code will run but it won't do very much.</p>\n<p>There's still another bug: logic error in the resulting behavior, one of the hardest kinds of bugs to find because nothing crashes. To help you find it, <strong>there's a secret message</strong> explaining how to fix it inside the global <code>message</code> variable, but that message is only there part-way through a run of the program. Find the message and make the final fix to complete the MP.</p>\n<h1>Submission and Grading</h1>\n<p>Only edit <code>gif.c</code>, none of the other files we provide.\n<code>gif.c</code> is the only file you can upload so if you change anything else your code won't work the same for you as it does for us.</p>\n<p>When you think you are done, <code>make test</code> will run all our tests and report what grade we think you've earned.</p>\n<p>Once you've passed all the tests, submit your code on the upload site.</p>\n<p>The final line of output from <code>make test</code> will be <code>SCORE: 0 / 1</code> or <code>SCORE: 1 / 1</code>:\nthis tells you how much credit you'll get if you submit this code.</p>\n<p>You may submit as often as you like, including replacing old submissions.\nThis is true of all MPs.\nOnly your last submission (prior to the end of the late submission window) will be included in your grade.</p>"
    },
    "_id": "mps/mp1.md",
    "_raw": {
      "sourceFilePath": "mps/mp1.md",
      "sourceFileName": "mp1.md",
      "sourceFileDir": "mps",
      "contentType": "markdown",
      "flattenedPath": "mps/mp1"
    },
    "type": "MP",
    "url": "/mps/mp1",
    "slug": "mp1",
    "number": 1
  },
  {
    "title": "MP2",
    "subtitle": "C++ to C",
    "author": "Luther Tychonievich",
    "body": {
      "raw": "\nThis is not a full MP; it is primarily testing your setup and ensuring you are ready for subsequent MPs.\nIt is **dramatically easier** than other MPs.\nDon't plan your time on other MPs based on this one.\n\nThis MP has only one goal: to help you understand how C is unlike C++.\n\nWe give you a C++ reference implementation of a doubly-linked list, with a simple driver program.\nWe also give you a C header file and driver program for a C version of the doubly-linked list.\nYour task is to write the corresponding doubly-linked list C source file.\nThis will mostly consist of copying C++ code to the C file, then changing the C++-specific parts to be C-specific instead.\n\n**Don't use AI**\n\nAI systems can do this assignment without any trouble. So can our TAs, others who took this course before, and many other people.\n\nDon't ask them to. Do this assignment yourself.\n\nThis MP is primarily intended to help you understand C so that later MPs will be easier to do. If you have someone or something else do the MP for you, that learning won't happen and you'll find later MPs much harder as a consequence.\n\nYou might find \"C without the ++\" to be a useful resource when working on this MP.\n\n# Initial Files\n\n`mp2.zip` contains a reference C++ implementation, a non-functioning C implementation, and build and testing supports like a Makefile and vscode project files.\n\nThe provided `dll.c` **does not compile** because it does not define the functions required by `dll.h`. Our first recommended step below is to add enough that it does compile.\n\nThe starter file does not include `stdio.h`, and you should not add it. Do not use any printing functions (such as `printf`) in your code. Instead, we recommend using the debugger. That lack of printing will be checked by `make test`, the command used to grade your code.\n\n# Machine Problem\n\nImplement a C version of the provided C++ code.\n\nWe recommend the following flow:\n\n1. Stub out the implementation. That is, do the minimum possible to make it compile, generally by making empty or return-only function bodies.\n\n2. Copy one function body from C++ to C and edit it to remove compiler errors. Pay particular attention to pointers and initialization: C++ calls initializers and destructors automatically which C does not.\n\n3. Repeat until all functions are done.\n\n4. Try it and debug it with the debugger.\n\n## C you will need\n\nYou'll probably want to use `strlen`, `free`, and either `malloc` or `calloc`. Other functions defined in `string.h`, like `strcmp` and `memset`, are also permitted. The tests will verify that those are the only library functions that you use.\n\nYou'll be required to meet all the rules of C. This will be enforced by compiling with the following compiler flags:\n\n**-Wall**\n:   Enable all the warnings, even those that programmers often ignore.\n\n**-Werror**\n:   Makes warnings into errors, refusing to compile if there are warnings.\n\n**-pedantic-errors**\n:   Emit errors for things that the standard specifies but the compiler knows how to ignore.\n\n**-std=c17**\n:   Uses the official 2017 standard version of C, the last version to be widely supported by compilers.\n\nYou must not have any memory errors or leaks. This will be enforced in part using valgrind; the following invocation\n\n```sh\nvalgrind --leak-check=full --show-leak-kinds=all ./dll_c whatever other arguments you want\n```\n\nmust end with an \"ERROR SUMMARY\" reporting \"0 errors\" and no other error messages.\n\n## Guide to changing C++ into C\n\n### Replace namespaces with name prefixes\n\nIn C++, namespaces help different libraries not collide. In C, the tradition is to prefix every function and global variable name with the same prefix, like `glViewport` instead of just `viewport` in OpenGL or `sqlite3_open` instead of `open` in SQLite.\n\nWe use the prefix `dll` (double linked list) in our provided header file.\n\n### Replace overloads and templates with name suffixes\n\nIn C++, `foo(int)` and `foo(double)` can co-exist; in C they cannot. The traditional solution is to add a type-specific suffix to the function name, like `sqrt(double)` and `sqrtf(float)`. If there's just a single parameter, suffixes based on `printf` percent codes are common; for anything more complicated there's no single pattern.\n\nTemplated functions can be removed in a similar type-suffix way, but if there's more than a few types expected it is more common to replace the templated-type argument with something like a type code and a `void *`.\n\nWe used the suffix `c` for what in C++ was a `<char>` template, and `s` for what was a `<std::string>` template.\n\n### Explicit `this`\n\nC has no built-in object orientation. As long as you are not using inheritance, this is a relatively small obstacle; just add the `this`-argument as the explicit first argument of each method and add a namespace-like renaming.\n\n**Example:**\n\nThis C++ class\n\n```cpp\nclass Pt2D {\n  double x,y;\n  Pt2D(double x, double y) { this.x = x; this.y = y; }\n  void move(double x, double y) { this.x += x; this.y += y; }\n  double theta() { return atan2(y, x); }\n  double r() { return hypot(x,y); }\n};\n```\n\nbecomes this C code: a `.h` file containing\n\n```c\ntypedef struct {\n  double x,y;\n} Pt2D;\nvoid pt2d_init(Pt2D *self, double x, double y);\nvoid pt2d_move(Pt2D *self, double x, double y);\ndouble pt2d_theta(Pt2D *self);\ndouble pt2d_r(Pt2D *self);\n```\n\nand a `.c` file containing\n\n```c\n#include \"the h file you created.h\"\n\nvoid pt2d_init(Pt2D *self, double x, double y) { self->x = x; self->y = y; }\nvoid pt2d_move(Pt2D *self, double x, double y) { self->x += x; self->y += y; }\ndouble pt2d_theta(Pt2D *self) { return atan2(self->y, self->x); }\ndouble pt2d_r(Pt2D *self) { return hypot(self->y, self->x); }\n```\n\nNote the above assumes a two-step creation: allocate, then initialize. If the intent is to always initialize on the heap (like C++'s `new` operator does) then we could instead (or in addition) do something like this:\n\n```c\nPt2D *pt2d_new(double x, double y) {\n  Pt2D *self = malloc(sizeof(Pt2D);\n  self->x = x; self->y = y;\n  return self;\n}\nvoid pt2d_delete(Pt2D *self) { free(self); }\n```\n\n### Language tweaks\n\nReplace `new` with `malloc` + initialization.\n\nReplace `delete` with `free` (preceded by deinitialization if there's a destructor).\n\nReplace `std::string` with `char *`.\n\nReplace operator overloading with explicit function calls: `strcat` instead of `std::string`'s `+` operator, `printf` instead of `cout`'s `<<` operator, and so on.\n\nThere are no `auto` declarations, iterator loops, or lambda expressions in C.\n\nReplace pass-by-reference code with pass-by-pointer, adding needed `*`/`->` operators to make that work.\n\nTo match prevailing style, move where `*`s appear in type declarations. In C it is tradition to write `int *x`, not `int* x` like in C++. It is also traditional to declare multiple pointers per line, like `int *x, *y`.\n\n# Testing Your Program\n\n- Compile with `make`\n- Test with `python3 tests.py`\n    - If this does not run on your computer, you can do what it does manually:\n        1. `make clean` followed by `make dll_c` should create `dll_c`\n        2. `dll_c` and `dll_cpp` should have the same operation as one another, including with the following arguments:\n            - `e`\n            - `e f`\n            - `one`\n            - `one two three four five six`\n            - `--help`\n            - `one --help two`\n        3. `valgrind` should report no errors\n\n**Note: Permissive grading**\n\nThe provided tests for this MP do not test all features of the MP (intentionally: the goal of this MP is writing C, not writing robust code).\n\n# Submission and Grading\n\nSubmit on the submission site. Only submit `dll.c`; do not modify any other file.\n\n## Grading\n\nThis assignment is primarily a warm-up, graded fairly loosely. The score created by `make test` is the score you get on this MP.\n",
      "html": "<p>This is not a full MP; it is primarily testing your setup and ensuring you are ready for subsequent MPs.\nIt is <strong>dramatically easier</strong> than other MPs.\nDon't plan your time on other MPs based on this one.</p>\n<p>This MP has only one goal: to help you understand how C is unlike C++.</p>\n<p>We give you a C++ reference implementation of a doubly-linked list, with a simple driver program.\nWe also give you a C header file and driver program for a C version of the doubly-linked list.\nYour task is to write the corresponding doubly-linked list C source file.\nThis will mostly consist of copying C++ code to the C file, then changing the C++-specific parts to be C-specific instead.</p>\n<p><strong>Don't use AI</strong></p>\n<p>AI systems can do this assignment without any trouble. So can our TAs, others who took this course before, and many other people.</p>\n<p>Don't ask them to. Do this assignment yourself.</p>\n<p>This MP is primarily intended to help you understand C so that later MPs will be easier to do. If you have someone or something else do the MP for you, that learning won't happen and you'll find later MPs much harder as a consequence.</p>\n<p>You might find \"C without the ++\" to be a useful resource when working on this MP.</p>\n<h1>Initial Files</h1>\n<p><code>mp2.zip</code> contains a reference C++ implementation, a non-functioning C implementation, and build and testing supports like a Makefile and vscode project files.</p>\n<p>The provided <code>dll.c</code> <strong>does not compile</strong> because it does not define the functions required by <code>dll.h</code>. Our first recommended step below is to add enough that it does compile.</p>\n<p>The starter file does not include <code>stdio.h</code>, and you should not add it. Do not use any printing functions (such as <code>printf</code>) in your code. Instead, we recommend using the debugger. That lack of printing will be checked by <code>make test</code>, the command used to grade your code.</p>\n<h1>Machine Problem</h1>\n<p>Implement a C version of the provided C++ code.</p>\n<p>We recommend the following flow:</p>\n<ol>\n<li>\n<p>Stub out the implementation. That is, do the minimum possible to make it compile, generally by making empty or return-only function bodies.</p>\n</li>\n<li>\n<p>Copy one function body from C++ to C and edit it to remove compiler errors. Pay particular attention to pointers and initialization: C++ calls initializers and destructors automatically which C does not.</p>\n</li>\n<li>\n<p>Repeat until all functions are done.</p>\n</li>\n<li>\n<p>Try it and debug it with the debugger.</p>\n</li>\n</ol>\n<h2>C you will need</h2>\n<p>You'll probably want to use <code>strlen</code>, <code>free</code>, and either <code>malloc</code> or <code>calloc</code>. Other functions defined in <code>string.h</code>, like <code>strcmp</code> and <code>memset</code>, are also permitted. The tests will verify that those are the only library functions that you use.</p>\n<p>You'll be required to meet all the rules of C. This will be enforced by compiling with the following compiler flags:</p>\n<p><strong>-Wall</strong>\n:   Enable all the warnings, even those that programmers often ignore.</p>\n<p><strong>-Werror</strong>\n:   Makes warnings into errors, refusing to compile if there are warnings.</p>\n<p><strong>-pedantic-errors</strong>\n:   Emit errors for things that the standard specifies but the compiler knows how to ignore.</p>\n<p><strong>-std=c17</strong>\n:   Uses the official 2017 standard version of C, the last version to be widely supported by compilers.</p>\n<p>You must not have any memory errors or leaks. This will be enforced in part using valgrind; the following invocation</p>\n<pre><code class=\"language-sh\">valgrind --leak-check=full --show-leak-kinds=all ./dll_c whatever other arguments you want\n</code></pre>\n<p>must end with an \"ERROR SUMMARY\" reporting \"0 errors\" and no other error messages.</p>\n<h2>Guide to changing C++ into C</h2>\n<h3>Replace namespaces with name prefixes</h3>\n<p>In C++, namespaces help different libraries not collide. In C, the tradition is to prefix every function and global variable name with the same prefix, like <code>glViewport</code> instead of just <code>viewport</code> in OpenGL or <code>sqlite3_open</code> instead of <code>open</code> in SQLite.</p>\n<p>We use the prefix <code>dll</code> (double linked list) in our provided header file.</p>\n<h3>Replace overloads and templates with name suffixes</h3>\n<p>In C++, <code>foo(int)</code> and <code>foo(double)</code> can co-exist; in C they cannot. The traditional solution is to add a type-specific suffix to the function name, like <code>sqrt(double)</code> and <code>sqrtf(float)</code>. If there's just a single parameter, suffixes based on <code>printf</code> percent codes are common; for anything more complicated there's no single pattern.</p>\n<p>Templated functions can be removed in a similar type-suffix way, but if there's more than a few types expected it is more common to replace the templated-type argument with something like a type code and a <code>void *</code>.</p>\n<p>We used the suffix <code>c</code> for what in C++ was a <code>&#x3C;char></code> template, and <code>s</code> for what was a <code>&#x3C;std::string></code> template.</p>\n<h3>Explicit <code>this</code></h3>\n<p>C has no built-in object orientation. As long as you are not using inheritance, this is a relatively small obstacle; just add the <code>this</code>-argument as the explicit first argument of each method and add a namespace-like renaming.</p>\n<p><strong>Example:</strong></p>\n<p>This C++ class</p>\n<pre><code class=\"language-cpp\">class Pt2D {\n  double x,y;\n  Pt2D(double x, double y) { this.x = x; this.y = y; }\n  void move(double x, double y) { this.x += x; this.y += y; }\n  double theta() { return atan2(y, x); }\n  double r() { return hypot(x,y); }\n};\n</code></pre>\n<p>becomes this C code: a <code>.h</code> file containing</p>\n<pre><code class=\"language-c\">typedef struct {\n  double x,y;\n} Pt2D;\nvoid pt2d_init(Pt2D *self, double x, double y);\nvoid pt2d_move(Pt2D *self, double x, double y);\ndouble pt2d_theta(Pt2D *self);\ndouble pt2d_r(Pt2D *self);\n</code></pre>\n<p>and a <code>.c</code> file containing</p>\n<pre><code class=\"language-c\">#include \"the h file you created.h\"\n\nvoid pt2d_init(Pt2D *self, double x, double y) { self->x = x; self->y = y; }\nvoid pt2d_move(Pt2D *self, double x, double y) { self->x += x; self->y += y; }\ndouble pt2d_theta(Pt2D *self) { return atan2(self->y, self->x); }\ndouble pt2d_r(Pt2D *self) { return hypot(self->y, self->x); }\n</code></pre>\n<p>Note the above assumes a two-step creation: allocate, then initialize. If the intent is to always initialize on the heap (like C++'s <code>new</code> operator does) then we could instead (or in addition) do something like this:</p>\n<pre><code class=\"language-c\">Pt2D *pt2d_new(double x, double y) {\n  Pt2D *self = malloc(sizeof(Pt2D);\n  self->x = x; self->y = y;\n  return self;\n}\nvoid pt2d_delete(Pt2D *self) { free(self); }\n</code></pre>\n<h3>Language tweaks</h3>\n<p>Replace <code>new</code> with <code>malloc</code> + initialization.</p>\n<p>Replace <code>delete</code> with <code>free</code> (preceded by deinitialization if there's a destructor).</p>\n<p>Replace <code>std::string</code> with <code>char *</code>.</p>\n<p>Replace operator overloading with explicit function calls: <code>strcat</code> instead of <code>std::string</code>'s <code>+</code> operator, <code>printf</code> instead of <code>cout</code>'s <code>&#x3C;&#x3C;</code> operator, and so on.</p>\n<p>There are no <code>auto</code> declarations, iterator loops, or lambda expressions in C.</p>\n<p>Replace pass-by-reference code with pass-by-pointer, adding needed <code>*</code>/<code>-></code> operators to make that work.</p>\n<p>To match prevailing style, move where <code>*</code>s appear in type declarations. In C it is tradition to write <code>int *x</code>, not <code>int* x</code> like in C++. It is also traditional to declare multiple pointers per line, like <code>int *x, *y</code>.</p>\n<h1>Testing Your Program</h1>\n<ul>\n<li>Compile with <code>make</code></li>\n<li>Test with <code>python3 tests.py</code>\n<ul>\n<li>If this does not run on your computer, you can do what it does manually:\n<ol>\n<li><code>make clean</code> followed by <code>make dll_c</code> should create <code>dll_c</code></li>\n<li><code>dll_c</code> and <code>dll_cpp</code> should have the same operation as one another, including with the following arguments:\n<ul>\n<li><code>e</code></li>\n<li><code>e f</code></li>\n<li><code>one</code></li>\n<li><code>one two three four five six</code></li>\n<li><code>--help</code></li>\n<li><code>one --help two</code></li>\n</ul>\n</li>\n<li><code>valgrind</code> should report no errors</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Note: Permissive grading</strong></p>\n<p>The provided tests for this MP do not test all features of the MP (intentionally: the goal of this MP is writing C, not writing robust code).</p>\n<h1>Submission and Grading</h1>\n<p>Submit on the submission site. Only submit <code>dll.c</code>; do not modify any other file.</p>\n<h2>Grading</h2>\n<p>This assignment is primarily a warm-up, graded fairly loosely. The score created by <code>make test</code> is the score you get on this MP.</p>"
    },
    "_id": "mps/mp2.md",
    "_raw": {
      "sourceFilePath": "mps/mp2.md",
      "sourceFileName": "mp2.md",
      "sourceFileDir": "mps",
      "contentType": "markdown",
      "flattenedPath": "mps/mp2"
    },
    "type": "MP",
    "url": "/mps/mp2",
    "slug": "mp2",
    "number": 2
  }
]