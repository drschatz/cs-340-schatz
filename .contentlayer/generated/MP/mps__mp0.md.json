{
  "title": "MP0",
  "subtitle": "IDE and Debugger",
  "author": "Wade Fagen-Ulmschneider",
  "body": {
    "raw": "\nThis is not a full MP; it is primarily testing your setup and ensuring you are ready for subsequent MPs.\nIt is **dramatically easier** than other MPs.\nDon't plan your time on other MPs based on this one.\n\nThe purposes of this MP are:\n\n1. Ensure you are set up to do other C-language MPs in this course.\n2. Have you see some of the tools the VS Code debugger can do.\n\nIs it possible to create the required `gif.c` without doing these two things? Yes. Should you do that? No.\n\n# Set up your environment\n\nFollow the directions on the MP environment setup page. We'll only use the local toolchain in this MP.\n\n# Fetch starter code\n\nWe have some initial code for your `mp0` for you to get started. Download it from `mp0.zip` and unzip it on your computer into the `cs340` directory you created during the environment setup.\n\n# Use Visual Studio Code\n\nVisual Studio Code (more often called VS Code) is an Integrated Development Environment (IDE) with many features shared with other IDEs. Learning to use it well will help you feel comfortable in other IDEs you may use in the future.\n\n## Projects\n\nIDEs have the notion of projects, which contain a set of files related to a single task or program. Typically, these reside in a folder and all of its subfolders. In this class, each MP will be its own project, meaning you need to open VS Code in `mp0` or `mp1` or the like, not in some parent folder that contains them all.\n\nA folder that is set up to be a VS Code project will have inside of it a folder named `.vscode`. In many systems files and folders with names that start with a `.` are hidden from view.\n\nTo open the `mp0` folder in VS Code, do one of the following:\n\n- From a terminal, `cd` into the `mp0` folder and run `code .`\n- Inside of VS Code, use File → Open Folder to open a new folder.\n\n## Integrated Terminal\n\nIDEs give access to the terminal, but often add configuration so that it's got everything needed to build the project ready to use. To open VS Code's integrated terminal, use the keyboard shortcut Ctrl+~.\n\nUsing the integrated terminal, let's verify you are all set up for running C programs by doing the following:\n\n- On your terminal, run `make` to compile the provided code.\n- If you receive any errors, read the error messages. They will often be helpful to describe what's going wrong. If you're stuck here, reach out to get help!\n\n## Visual Debugger\n\nIDEs provide a user interface over the normal debugger tools for your language. In VS Code, the debugger tool to use and how to attach it to the visual debugger is defined in `.vscode/launch.json`. Designing these configuration files is not a goal of this course, so we provide them for each MP.\n\nOur `launch.json` files for `C` programs use `Makefile`s, one of the oldest and best-established command-line build management tools. You can compile your code from the command line by typing `make` and run any tests we provided by typing `make test`. The `launch.json` will do these two commands but attach a debugger to the running code, and may also have other commands for handling specific cases in some MPs.\n\nYou can run VS Code's debugger in two ways:\n\n- On the left side of Visual Studio Code, find the \"Run and Debug\" Interface\n- Once on the \"Run and Debug\" interface, find the green \"Debug\" arrow to start your program with a visual debugger\n\nDepending on the project, it may ask you to pick a launch configuration to run and may ask for per-run configuration.\n\nFor MP0, start by accepting the defaults when you run the debugger. After a moment the debugger will pause execution because of a segmentation fault.\n\n# Debug the Code\n\nTo help you learn how to use the debugger, we provide a version of `gif.c` that has multiple bugs inserted. Each bug is designed to help you see the value of a different aspect of the debugger.\n\nEach bug can be fixed by editing a single line of code in `gif.c`: all but one by commenting out a line and the last by making one change to a line. That's obviously not true of most real bugs: they tend to span many lines and even many files. Our goal in this MP is not to show you what real bugs look like, it's to show you what the debugger can do.\n\n## Segmentation fault\n\nA segmentation fault occurs when code tries to dereference a pointer to memory that is not in use. Memory references occur with the `*address`, `address->`, and `address[offset]` operators. Debuggers are very good at locating segmentation faults, but the bug that caused the fault is often in an earlier line that computed the address (or failed to do so).\n\nMP0 has several segmentation faults.\n\n## Stack Smashing\n\nStack smashing occurs when code tries to change memory that belongs to a different function's activation record.\n\nRecall that each function is given a region of memory on the call stack, called an activation record, in which to store its arguments and local variables. The function that called the current function's activation record is right after the current activation record in memory. In between these two the compiler inserts special guards to make sure memory accesses don't cross the boundary: if they do, that's stack smashing.\n\nStack smashing is one of several bugs that will have information printed to the terminal, not just alerted in the debugger.\n\nMP0 has only one stack smashing error.\n\n## Call Stack Inspection\n\nWhen the debugger pauses, either on an error or because you added a breakpoint, the \"Run and Debug\" window shows a wealth of useful debugging information.\n\nOne panel is labeled \"Call Stack\". It will list the function calls that were called leading to where your program is currently paused. You can click on them to jump to their location in code.\n\nIn a call stack, the top is the most recent function called. The call stack is very useful for finding infinite recursion if you see the same function name again and again and again. You will want to reference the call stack for several bugs in `mp0`.\n\n## Pause-and-step\n\nIf there's an infinite loop, the program will appear to make no progress. In that case, you can pause the debugger and step through the code to see what is happening.\n\nPressing the left-most \"Pause\" button will pause the execution of the program and provide you information about the current point of execution. When the program is paused:\n\n- You can hover over variables to see the values their hold\n- You can view the call stack and other debugging information\n- You can use the control window to step through your code line-by-line\n\n## Breakpoints\n\nWhen a program is doing the wrong thing, the most common approach to debug is to set a breakpoint. This means picking a line of code and telling the debugger to pause when it reaches that line (before it runs it).\n\nTo set a breakpoint, click on the space immediately to the left of the line number. A bright red dot will appear to indicate that an active breakpoint is set.\n\nIn the example above, execution will pause after running Line 834 but before running Line 835. Since it's paused, you can inspect all of the variables at the exact moment before running Line 835. If you resume the program and the breakpoint is encountered again, it will pause again.\n\nIf you've done print-based debugging before, that's a sloppy way of trying to approximate a breakpoint + hovering over variables without using a debugger.\n\n## Watches and Beyond\n\nSometimes a variable changes many times, with the information you need to debug it appearing and then disappearing later. There are multiple debugging tools for these situations, which can get quite involved; two of the simpler such tools are watches and conditional breakpoints.\n\nIn MP0 we have one bug that could benefit from these tools, though it could also be debugged with a breakpoint and stepping if you are patient. After you've fixed all the obvious bugs the code will run but it won't do very much.\n\nThere's still another bug: logic error in the resulting behavior, one of the hardest kinds of bugs to find because nothing crashes. To help you find it, there's a secret message explaining how to fix it inside the global `message` variable, but that message is only there part-way through a run of the program. Find the message and make the final fix to complete the MP.\n\n# Submission and Grading\n\nOnly edit `gif.c`, none of the other files we provide. `gif.c` is the only file you can upload so if you change anything else your code won't work the same for you as it does for us.\n\nWhen you think you are done, `make test` will run all our tests and report what grade we think you've earned.\n\nOnce you've passed all the tests, submit your code on the upload site.\n\nThis MP has very low weight, all-or-nothing grading, and accepts late submissions at no grade penalty.\n\nThe final line of output from `make test` will be `SCORE: 0 / 1` or `SCORE: 1 / 1`: this tells you how much credit you'll get if you submit this code.\n\nYou may submit as often as you like, including replacing old submissions. This is true of all MPs. Only your last submission (prior to the end of the late submission window) will be included in your grade.\n",
    "html": "<p>This is not a full MP; it is primarily testing your setup and ensuring you are ready for subsequent MPs.\nIt is <strong>dramatically easier</strong> than other MPs.\nDon't plan your time on other MPs based on this one.</p>\n<p>The purposes of this MP are:</p>\n<ol>\n<li>Ensure you are set up to do other C-language MPs in this course.</li>\n<li>Have you see some of the tools the VS Code debugger can do.</li>\n</ol>\n<p>Is it possible to create the required <code>gif.c</code> without doing these two things? Yes. Should you do that? No.</p>\n<h1>Set up your environment</h1>\n<p>Follow the directions on the MP environment setup page. We'll only use the local toolchain in this MP.</p>\n<h1>Fetch starter code</h1>\n<p>We have some initial code for your <code>mp0</code> for you to get started. Download it from <code>mp0.zip</code> and unzip it on your computer into the <code>cs340</code> directory you created during the environment setup.</p>\n<h1>Use Visual Studio Code</h1>\n<p>Visual Studio Code (more often called VS Code) is an Integrated Development Environment (IDE) with many features shared with other IDEs. Learning to use it well will help you feel comfortable in other IDEs you may use in the future.</p>\n<h2>Projects</h2>\n<p>IDEs have the notion of projects, which contain a set of files related to a single task or program. Typically, these reside in a folder and all of its subfolders. In this class, each MP will be its own project, meaning you need to open VS Code in <code>mp0</code> or <code>mp1</code> or the like, not in some parent folder that contains them all.</p>\n<p>A folder that is set up to be a VS Code project will have inside of it a folder named <code>.vscode</code>. In many systems files and folders with names that start with a <code>.</code> are hidden from view.</p>\n<p>To open the <code>mp0</code> folder in VS Code, do one of the following:</p>\n<ul>\n<li>From a terminal, <code>cd</code> into the <code>mp0</code> folder and run <code>code .</code></li>\n<li>Inside of VS Code, use File → Open Folder to open a new folder.</li>\n</ul>\n<h2>Integrated Terminal</h2>\n<p>IDEs give access to the terminal, but often add configuration so that it's got everything needed to build the project ready to use. To open VS Code's integrated terminal, use the keyboard shortcut Ctrl+~.</p>\n<p>Using the integrated terminal, let's verify you are all set up for running C programs by doing the following:</p>\n<ul>\n<li>On your terminal, run <code>make</code> to compile the provided code.</li>\n<li>If you receive any errors, read the error messages. They will often be helpful to describe what's going wrong. If you're stuck here, reach out to get help!</li>\n</ul>\n<h2>Visual Debugger</h2>\n<p>IDEs provide a user interface over the normal debugger tools for your language. In VS Code, the debugger tool to use and how to attach it to the visual debugger is defined in <code>.vscode/launch.json</code>. Designing these configuration files is not a goal of this course, so we provide them for each MP.</p>\n<p>Our <code>launch.json</code> files for <code>C</code> programs use <code>Makefile</code>s, one of the oldest and best-established command-line build management tools. You can compile your code from the command line by typing <code>make</code> and run any tests we provided by typing <code>make test</code>. The <code>launch.json</code> will do these two commands but attach a debugger to the running code, and may also have other commands for handling specific cases in some MPs.</p>\n<p>You can run VS Code's debugger in two ways:</p>\n<ul>\n<li>On the left side of Visual Studio Code, find the \"Run and Debug\" Interface</li>\n<li>Once on the \"Run and Debug\" interface, find the green \"Debug\" arrow to start your program with a visual debugger</li>\n</ul>\n<p>Depending on the project, it may ask you to pick a launch configuration to run and may ask for per-run configuration.</p>\n<p>For MP0, start by accepting the defaults when you run the debugger. After a moment the debugger will pause execution because of a segmentation fault.</p>\n<h1>Debug the Code</h1>\n<p>To help you learn how to use the debugger, we provide a version of <code>gif.c</code> that has multiple bugs inserted. Each bug is designed to help you see the value of a different aspect of the debugger.</p>\n<p>Each bug can be fixed by editing a single line of code in <code>gif.c</code>: all but one by commenting out a line and the last by making one change to a line. That's obviously not true of most real bugs: they tend to span many lines and even many files. Our goal in this MP is not to show you what real bugs look like, it's to show you what the debugger can do.</p>\n<h2>Segmentation fault</h2>\n<p>A segmentation fault occurs when code tries to dereference a pointer to memory that is not in use. Memory references occur with the <code>*address</code>, <code>address-></code>, and <code>address[offset]</code> operators. Debuggers are very good at locating segmentation faults, but the bug that caused the fault is often in an earlier line that computed the address (or failed to do so).</p>\n<p>MP0 has several segmentation faults.</p>\n<h2>Stack Smashing</h2>\n<p>Stack smashing occurs when code tries to change memory that belongs to a different function's activation record.</p>\n<p>Recall that each function is given a region of memory on the call stack, called an activation record, in which to store its arguments and local variables. The function that called the current function's activation record is right after the current activation record in memory. In between these two the compiler inserts special guards to make sure memory accesses don't cross the boundary: if they do, that's stack smashing.</p>\n<p>Stack smashing is one of several bugs that will have information printed to the terminal, not just alerted in the debugger.</p>\n<p>MP0 has only one stack smashing error.</p>\n<h2>Call Stack Inspection</h2>\n<p>When the debugger pauses, either on an error or because you added a breakpoint, the \"Run and Debug\" window shows a wealth of useful debugging information.</p>\n<p>One panel is labeled \"Call Stack\". It will list the function calls that were called leading to where your program is currently paused. You can click on them to jump to their location in code.</p>\n<p>In a call stack, the top is the most recent function called. The call stack is very useful for finding infinite recursion if you see the same function name again and again and again. You will want to reference the call stack for several bugs in <code>mp0</code>.</p>\n<h2>Pause-and-step</h2>\n<p>If there's an infinite loop, the program will appear to make no progress. In that case, you can pause the debugger and step through the code to see what is happening.</p>\n<p>Pressing the left-most \"Pause\" button will pause the execution of the program and provide you information about the current point of execution. When the program is paused:</p>\n<ul>\n<li>You can hover over variables to see the values their hold</li>\n<li>You can view the call stack and other debugging information</li>\n<li>You can use the control window to step through your code line-by-line</li>\n</ul>\n<h2>Breakpoints</h2>\n<p>When a program is doing the wrong thing, the most common approach to debug is to set a breakpoint. This means picking a line of code and telling the debugger to pause when it reaches that line (before it runs it).</p>\n<p>To set a breakpoint, click on the space immediately to the left of the line number. A bright red dot will appear to indicate that an active breakpoint is set.</p>\n<p>In the example above, execution will pause after running Line 834 but before running Line 835. Since it's paused, you can inspect all of the variables at the exact moment before running Line 835. If you resume the program and the breakpoint is encountered again, it will pause again.</p>\n<p>If you've done print-based debugging before, that's a sloppy way of trying to approximate a breakpoint + hovering over variables without using a debugger.</p>\n<h2>Watches and Beyond</h2>\n<p>Sometimes a variable changes many times, with the information you need to debug it appearing and then disappearing later. There are multiple debugging tools for these situations, which can get quite involved; two of the simpler such tools are watches and conditional breakpoints.</p>\n<p>In MP0 we have one bug that could benefit from these tools, though it could also be debugged with a breakpoint and stepping if you are patient. After you've fixed all the obvious bugs the code will run but it won't do very much.</p>\n<p>There's still another bug: logic error in the resulting behavior, one of the hardest kinds of bugs to find because nothing crashes. To help you find it, there's a secret message explaining how to fix it inside the global <code>message</code> variable, but that message is only there part-way through a run of the program. Find the message and make the final fix to complete the MP.</p>\n<h1>Submission and Grading</h1>\n<p>Only edit <code>gif.c</code>, none of the other files we provide. <code>gif.c</code> is the only file you can upload so if you change anything else your code won't work the same for you as it does for us.</p>\n<p>When you think you are done, <code>make test</code> will run all our tests and report what grade we think you've earned.</p>\n<p>Once you've passed all the tests, submit your code on the upload site.</p>\n<p>This MP has very low weight, all-or-nothing grading, and accepts late submissions at no grade penalty.</p>\n<p>The final line of output from <code>make test</code> will be <code>SCORE: 0 / 1</code> or <code>SCORE: 1 / 1</code>: this tells you how much credit you'll get if you submit this code.</p>\n<p>You may submit as often as you like, including replacing old submissions. This is true of all MPs. Only your last submission (prior to the end of the late submission window) will be included in your grade.</p>"
  },
  "_id": "mps/mp0.md",
  "_raw": {
    "sourceFilePath": "mps/mp0.md",
    "sourceFileName": "mp0.md",
    "sourceFileDir": "mps",
    "contentType": "markdown",
    "flattenedPath": "mps/mp0"
  },
  "type": "MP",
  "url": "/mps/mp0",
  "slug": "mp0",
  "number": 0
}