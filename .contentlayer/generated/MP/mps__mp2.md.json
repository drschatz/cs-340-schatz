{
  "title": "MP2",
  "subtitle": "C++ to C",
  "author": "Luther Tychonievich",
  "body": {
    "raw": "\nThis is not a full MP; it is primarily testing your setup and ensuring you are ready for subsequent MPs.\nIt is **dramatically easier** than other MPs.\nDon't plan your time on other MPs based on this one.\n\nThis MP has only one goal: to help you understand how C is unlike C++.\n\nWe give you a C++ reference implementation of a doubly-linked list, with a simple driver program.\nWe also give you a C header file and driver program for a C version of the doubly-linked list.\nYour task is to write the corresponding doubly-linked list C source file.\nThis will mostly consist of copying C++ code to the C file, then changing the C++-specific parts to be C-specific instead.\n\n**Don't use AI**\n\nAI systems can do this assignment without any trouble. So can our TAs, others who took this course before, and many other people.\n\nDon't ask them to. Do this assignment yourself.\n\nThis MP is primarily intended to help you understand C so that later MPs will be easier to do. If you have someone or something else do the MP for you, that learning won't happen and you'll find later MPs much harder as a consequence.\n\nYou might find \"C without the ++\" to be a useful resource when working on this MP.\n\n# Initial Files\n\n`mp2.zip` contains a reference C++ implementation, a non-functioning C implementation, and build and testing supports like a Makefile and vscode project files.\n\nThe provided `dll.c` **does not compile** because it does not define the functions required by `dll.h`. Our first recommended step below is to add enough that it does compile.\n\nThe starter file does not include `stdio.h`, and you should not add it. Do not use any printing functions (such as `printf`) in your code. Instead, we recommend using the debugger. That lack of printing will be checked by `make test`, the command used to grade your code.\n\n# Machine Problem\n\nImplement a C version of the provided C++ code.\n\nWe recommend the following flow:\n\n1. Stub out the implementation. That is, do the minimum possible to make it compile, generally by making empty or return-only function bodies.\n\n2. Copy one function body from C++ to C and edit it to remove compiler errors. Pay particular attention to pointers and initialization: C++ calls initializers and destructors automatically which C does not.\n\n3. Repeat until all functions are done.\n\n4. Try it and debug it with the debugger.\n\n## C you will need\n\nYou'll probably want to use `strlen`, `free`, and either `malloc` or `calloc`. Other functions defined in `string.h`, like `strcmp` and `memset`, are also permitted. The tests will verify that those are the only library functions that you use.\n\nYou'll be required to meet all the rules of C. This will be enforced by compiling with the following compiler flags:\n\n**-Wall**\n:   Enable all the warnings, even those that programmers often ignore.\n\n**-Werror**\n:   Makes warnings into errors, refusing to compile if there are warnings.\n\n**-pedantic-errors**\n:   Emit errors for things that the standard specifies but the compiler knows how to ignore.\n\n**-std=c17**\n:   Uses the official 2017 standard version of C, the last version to be widely supported by compilers.\n\nYou must not have any memory errors or leaks. This will be enforced in part using valgrind; the following invocation\n\n```sh\nvalgrind --leak-check=full --show-leak-kinds=all ./dll_c whatever other arguments you want\n```\n\nmust end with an \"ERROR SUMMARY\" reporting \"0 errors\" and no other error messages.\n\n## Guide to changing C++ into C\n\n### Replace namespaces with name prefixes\n\nIn C++, namespaces help different libraries not collide. In C, the tradition is to prefix every function and global variable name with the same prefix, like `glViewport` instead of just `viewport` in OpenGL or `sqlite3_open` instead of `open` in SQLite.\n\nWe use the prefix `dll` (double linked list) in our provided header file.\n\n### Replace overloads and templates with name suffixes\n\nIn C++, `foo(int)` and `foo(double)` can co-exist; in C they cannot. The traditional solution is to add a type-specific suffix to the function name, like `sqrt(double)` and `sqrtf(float)`. If there's just a single parameter, suffixes based on `printf` percent codes are common; for anything more complicated there's no single pattern.\n\nTemplated functions can be removed in a similar type-suffix way, but if there's more than a few types expected it is more common to replace the templated-type argument with something like a type code and a `void *`.\n\nWe used the suffix `c` for what in C++ was a `<char>` template, and `s` for what was a `<std::string>` template.\n\n### Explicit `this`\n\nC has no built-in object orientation. As long as you are not using inheritance, this is a relatively small obstacle; just add the `this`-argument as the explicit first argument of each method and add a namespace-like renaming.\n\n**Example:**\n\nThis C++ class\n\n```cpp\nclass Pt2D {\n  double x,y;\n  Pt2D(double x, double y) { this.x = x; this.y = y; }\n  void move(double x, double y) { this.x += x; this.y += y; }\n  double theta() { return atan2(y, x); }\n  double r() { return hypot(x,y); }\n};\n```\n\nbecomes this C code: a `.h` file containing\n\n```c\ntypedef struct {\n  double x,y;\n} Pt2D;\nvoid pt2d_init(Pt2D *self, double x, double y);\nvoid pt2d_move(Pt2D *self, double x, double y);\ndouble pt2d_theta(Pt2D *self);\ndouble pt2d_r(Pt2D *self);\n```\n\nand a `.c` file containing\n\n```c\n#include \"the h file you created.h\"\n\nvoid pt2d_init(Pt2D *self, double x, double y) { self->x = x; self->y = y; }\nvoid pt2d_move(Pt2D *self, double x, double y) { self->x += x; self->y += y; }\ndouble pt2d_theta(Pt2D *self) { return atan2(self->y, self->x); }\ndouble pt2d_r(Pt2D *self) { return hypot(self->y, self->x); }\n```\n\nNote the above assumes a two-step creation: allocate, then initialize. If the intent is to always initialize on the heap (like C++'s `new` operator does) then we could instead (or in addition) do something like this:\n\n```c\nPt2D *pt2d_new(double x, double y) {\n  Pt2D *self = malloc(sizeof(Pt2D);\n  self->x = x; self->y = y;\n  return self;\n}\nvoid pt2d_delete(Pt2D *self) { free(self); }\n```\n\n### Language tweaks\n\nReplace `new` with `malloc` + initialization.\n\nReplace `delete` with `free` (preceded by deinitialization if there's a destructor).\n\nReplace `std::string` with `char *`.\n\nReplace operator overloading with explicit function calls: `strcat` instead of `std::string`'s `+` operator, `printf` instead of `cout`'s `<<` operator, and so on.\n\nThere are no `auto` declarations, iterator loops, or lambda expressions in C.\n\nReplace pass-by-reference code with pass-by-pointer, adding needed `*`/`->` operators to make that work.\n\nTo match prevailing style, move where `*`s appear in type declarations. In C it is tradition to write `int *x`, not `int* x` like in C++. It is also traditional to declare multiple pointers per line, like `int *x, *y`.\n\n# Testing Your Program\n\n- Compile with `make`\n- Test with `python3 tests.py`\n    - If this does not run on your computer, you can do what it does manually:\n        1. `make clean` followed by `make dll_c` should create `dll_c`\n        2. `dll_c` and `dll_cpp` should have the same operation as one another, including with the following arguments:\n            - `e`\n            - `e f`\n            - `one`\n            - `one two three four five six`\n            - `--help`\n            - `one --help two`\n        3. `valgrind` should report no errors\n\n**Note: Permissive grading**\n\nThe provided tests for this MP do not test all features of the MP (intentionally: the goal of this MP is writing C, not writing robust code).\n\n# Submission and Grading\n\nSubmit on the submission site. Only submit `dll.c`; do not modify any other file.\n\n## Grading\n\nThis assignment is primarily a warm-up, graded fairly loosely. The score created by `make test` is the score you get on this MP.\n",
    "html": "<p>This is not a full MP; it is primarily testing your setup and ensuring you are ready for subsequent MPs.\nIt is <strong>dramatically easier</strong> than other MPs.\nDon't plan your time on other MPs based on this one.</p>\n<p>This MP has only one goal: to help you understand how C is unlike C++.</p>\n<p>We give you a C++ reference implementation of a doubly-linked list, with a simple driver program.\nWe also give you a C header file and driver program for a C version of the doubly-linked list.\nYour task is to write the corresponding doubly-linked list C source file.\nThis will mostly consist of copying C++ code to the C file, then changing the C++-specific parts to be C-specific instead.</p>\n<p><strong>Don't use AI</strong></p>\n<p>AI systems can do this assignment without any trouble. So can our TAs, others who took this course before, and many other people.</p>\n<p>Don't ask them to. Do this assignment yourself.</p>\n<p>This MP is primarily intended to help you understand C so that later MPs will be easier to do. If you have someone or something else do the MP for you, that learning won't happen and you'll find later MPs much harder as a consequence.</p>\n<p>You might find \"C without the ++\" to be a useful resource when working on this MP.</p>\n<h1>Initial Files</h1>\n<p><code>mp2.zip</code> contains a reference C++ implementation, a non-functioning C implementation, and build and testing supports like a Makefile and vscode project files.</p>\n<p>The provided <code>dll.c</code> <strong>does not compile</strong> because it does not define the functions required by <code>dll.h</code>. Our first recommended step below is to add enough that it does compile.</p>\n<p>The starter file does not include <code>stdio.h</code>, and you should not add it. Do not use any printing functions (such as <code>printf</code>) in your code. Instead, we recommend using the debugger. That lack of printing will be checked by <code>make test</code>, the command used to grade your code.</p>\n<h1>Machine Problem</h1>\n<p>Implement a C version of the provided C++ code.</p>\n<p>We recommend the following flow:</p>\n<ol>\n<li>\n<p>Stub out the implementation. That is, do the minimum possible to make it compile, generally by making empty or return-only function bodies.</p>\n</li>\n<li>\n<p>Copy one function body from C++ to C and edit it to remove compiler errors. Pay particular attention to pointers and initialization: C++ calls initializers and destructors automatically which C does not.</p>\n</li>\n<li>\n<p>Repeat until all functions are done.</p>\n</li>\n<li>\n<p>Try it and debug it with the debugger.</p>\n</li>\n</ol>\n<h2>C you will need</h2>\n<p>You'll probably want to use <code>strlen</code>, <code>free</code>, and either <code>malloc</code> or <code>calloc</code>. Other functions defined in <code>string.h</code>, like <code>strcmp</code> and <code>memset</code>, are also permitted. The tests will verify that those are the only library functions that you use.</p>\n<p>You'll be required to meet all the rules of C. This will be enforced by compiling with the following compiler flags:</p>\n<p><strong>-Wall</strong>\n:   Enable all the warnings, even those that programmers often ignore.</p>\n<p><strong>-Werror</strong>\n:   Makes warnings into errors, refusing to compile if there are warnings.</p>\n<p><strong>-pedantic-errors</strong>\n:   Emit errors for things that the standard specifies but the compiler knows how to ignore.</p>\n<p><strong>-std=c17</strong>\n:   Uses the official 2017 standard version of C, the last version to be widely supported by compilers.</p>\n<p>You must not have any memory errors or leaks. This will be enforced in part using valgrind; the following invocation</p>\n<pre><code class=\"language-sh\">valgrind --leak-check=full --show-leak-kinds=all ./dll_c whatever other arguments you want\n</code></pre>\n<p>must end with an \"ERROR SUMMARY\" reporting \"0 errors\" and no other error messages.</p>\n<h2>Guide to changing C++ into C</h2>\n<h3>Replace namespaces with name prefixes</h3>\n<p>In C++, namespaces help different libraries not collide. In C, the tradition is to prefix every function and global variable name with the same prefix, like <code>glViewport</code> instead of just <code>viewport</code> in OpenGL or <code>sqlite3_open</code> instead of <code>open</code> in SQLite.</p>\n<p>We use the prefix <code>dll</code> (double linked list) in our provided header file.</p>\n<h3>Replace overloads and templates with name suffixes</h3>\n<p>In C++, <code>foo(int)</code> and <code>foo(double)</code> can co-exist; in C they cannot. The traditional solution is to add a type-specific suffix to the function name, like <code>sqrt(double)</code> and <code>sqrtf(float)</code>. If there's just a single parameter, suffixes based on <code>printf</code> percent codes are common; for anything more complicated there's no single pattern.</p>\n<p>Templated functions can be removed in a similar type-suffix way, but if there's more than a few types expected it is more common to replace the templated-type argument with something like a type code and a <code>void *</code>.</p>\n<p>We used the suffix <code>c</code> for what in C++ was a <code>&#x3C;char></code> template, and <code>s</code> for what was a <code>&#x3C;std::string></code> template.</p>\n<h3>Explicit <code>this</code></h3>\n<p>C has no built-in object orientation. As long as you are not using inheritance, this is a relatively small obstacle; just add the <code>this</code>-argument as the explicit first argument of each method and add a namespace-like renaming.</p>\n<p><strong>Example:</strong></p>\n<p>This C++ class</p>\n<pre><code class=\"language-cpp\">class Pt2D {\n  double x,y;\n  Pt2D(double x, double y) { this.x = x; this.y = y; }\n  void move(double x, double y) { this.x += x; this.y += y; }\n  double theta() { return atan2(y, x); }\n  double r() { return hypot(x,y); }\n};\n</code></pre>\n<p>becomes this C code: a <code>.h</code> file containing</p>\n<pre><code class=\"language-c\">typedef struct {\n  double x,y;\n} Pt2D;\nvoid pt2d_init(Pt2D *self, double x, double y);\nvoid pt2d_move(Pt2D *self, double x, double y);\ndouble pt2d_theta(Pt2D *self);\ndouble pt2d_r(Pt2D *self);\n</code></pre>\n<p>and a <code>.c</code> file containing</p>\n<pre><code class=\"language-c\">#include \"the h file you created.h\"\n\nvoid pt2d_init(Pt2D *self, double x, double y) { self->x = x; self->y = y; }\nvoid pt2d_move(Pt2D *self, double x, double y) { self->x += x; self->y += y; }\ndouble pt2d_theta(Pt2D *self) { return atan2(self->y, self->x); }\ndouble pt2d_r(Pt2D *self) { return hypot(self->y, self->x); }\n</code></pre>\n<p>Note the above assumes a two-step creation: allocate, then initialize. If the intent is to always initialize on the heap (like C++'s <code>new</code> operator does) then we could instead (or in addition) do something like this:</p>\n<pre><code class=\"language-c\">Pt2D *pt2d_new(double x, double y) {\n  Pt2D *self = malloc(sizeof(Pt2D);\n  self->x = x; self->y = y;\n  return self;\n}\nvoid pt2d_delete(Pt2D *self) { free(self); }\n</code></pre>\n<h3>Language tweaks</h3>\n<p>Replace <code>new</code> with <code>malloc</code> + initialization.</p>\n<p>Replace <code>delete</code> with <code>free</code> (preceded by deinitialization if there's a destructor).</p>\n<p>Replace <code>std::string</code> with <code>char *</code>.</p>\n<p>Replace operator overloading with explicit function calls: <code>strcat</code> instead of <code>std::string</code>'s <code>+</code> operator, <code>printf</code> instead of <code>cout</code>'s <code>&#x3C;&#x3C;</code> operator, and so on.</p>\n<p>There are no <code>auto</code> declarations, iterator loops, or lambda expressions in C.</p>\n<p>Replace pass-by-reference code with pass-by-pointer, adding needed <code>*</code>/<code>-></code> operators to make that work.</p>\n<p>To match prevailing style, move where <code>*</code>s appear in type declarations. In C it is tradition to write <code>int *x</code>, not <code>int* x</code> like in C++. It is also traditional to declare multiple pointers per line, like <code>int *x, *y</code>.</p>\n<h1>Testing Your Program</h1>\n<ul>\n<li>Compile with <code>make</code></li>\n<li>Test with <code>python3 tests.py</code>\n<ul>\n<li>If this does not run on your computer, you can do what it does manually:\n<ol>\n<li><code>make clean</code> followed by <code>make dll_c</code> should create <code>dll_c</code></li>\n<li><code>dll_c</code> and <code>dll_cpp</code> should have the same operation as one another, including with the following arguments:\n<ul>\n<li><code>e</code></li>\n<li><code>e f</code></li>\n<li><code>one</code></li>\n<li><code>one two three four five six</code></li>\n<li><code>--help</code></li>\n<li><code>one --help two</code></li>\n</ul>\n</li>\n<li><code>valgrind</code> should report no errors</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Note: Permissive grading</strong></p>\n<p>The provided tests for this MP do not test all features of the MP (intentionally: the goal of this MP is writing C, not writing robust code).</p>\n<h1>Submission and Grading</h1>\n<p>Submit on the submission site. Only submit <code>dll.c</code>; do not modify any other file.</p>\n<h2>Grading</h2>\n<p>This assignment is primarily a warm-up, graded fairly loosely. The score created by <code>make test</code> is the score you get on this MP.</p>"
  },
  "_id": "mps/mp2.md",
  "_raw": {
    "sourceFilePath": "mps/mp2.md",
    "sourceFileName": "mp2.md",
    "sourceFileDir": "mps",
    "contentType": "markdown",
    "flattenedPath": "mps/mp2"
  },
  "type": "MP",
  "url": "/mps/mp2",
  "slug": "mp2",
  "number": 2
}